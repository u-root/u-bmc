// Copyright 2018 the u-root Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/x509"
	"encoding/pem"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"strings"
	"syscall"

	"github.com/vishvananda/netlink"
	"golang.org/x/sys/unix"
)

var (
	commands = []string{
		"/bbin/sshd --ip [::0] --port 22 --privatekey /conf/ssh_host_ecdsa_key --keys /conf/authorized_keys",
	}
)

func newSshKey() []byte {
	// No entropy, so use bad source for now
	f, err := os.Open("/dev/urandom")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	pk, err := ecdsa.GenerateKey(elliptic.P521(), f)
	if err != nil {
		panic(err)
	}

	asn1, err := x509.MarshalECPrivateKey(pk)
	if err != nil {
		panic(err)
	}
	return pem.EncodeToMemory(&pem.Block{Type: "EC PRIVATE KEY", Bytes: asn1})
}

func addIp(cidr string, iface string) {
	l, err := netlink.LinkByName(iface)
	if err != nil {
		log.Fatalf("Unable to get interface %s: %v", iface, err)
	}

	addr, err := netlink.ParseAddr(cidr)
	if err != nil {
		log.Fatalf("netlink.ParseAddr %v: %v", cidr, err)
	}

	h, err := netlink.NewHandle(unix.NETLINK_ROUTE)
	if err != nil {
		log.Fatalf("netlink.NewHandle: %v", err)
	}
	defer h.Delete()
	if err := h.AddrReplace(l, addr); err != nil {
		log.Fatalf("AddrReplace(%v): %v", addr, err)
	}
}

func setLinkUp(iface string) {
	l, err := netlink.LinkByName(iface)
	if err != nil {
		log.Fatalf("Unable to get interface %s: %v", iface, err)
	}

	h, err := netlink.NewHandle(unix.NETLINK_ROUTE)
	if err != nil {
		log.Fatalf("netlink.NewHandle: %v", err)
	}
	defer h.Delete()
	if err := h.LinkSetUp(l); err != nil {
		log.Fatalf("handle.LinkSetUp: %v", err)
	}
}

func createFile(file string, mode os.FileMode, c []byte) {
	f, err := os.OpenFile(file, os.O_RDWR|os.O_CREATE, mode)
	if err != nil {
		log.Printf("Failed to write %v: %v", file, err)
		return
	}
	defer f.Close()
	f.Write(c)
}

func intrHandler(cmd *exec.Cmd) {
	for {
		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt)
		_ = <-c
		cmd.Process.Signal(os.Interrupt)
	}
}

func main() {
	log.Printf("Configuring SOC\n")
	configureSoc()

	log.Printf("Starting GPIO drivers\n")
	startGpio("/dev/gpiochip0")

	log.Printf("Configuring UART ports\n")
	go startUart("/dev/ttyS2")

	log.Printf("Setting up Network Controller Sideband Interface (NC-SI) for eth0\n")
	go startNcsi("eth0")

	log.Printf("Loading system configuration\n")

	syscall.Sethostname([]byte("ubmc"))

	// TOOD(bluecmd): Need /dev/mem for platform libraries for now
	syscall.Mknod("/dev/mem", syscall.S_IFCHR|0600, 0x0101)

	// Fun story: if you don't have both IPv4 and IPv6 loopback configured
	// golang binaries will not bind to :: but to 0.0.0.0 instead.
	// Isn't that surprising?
	addIp("127.0.0.1/8", "lo")
	addIp("::1/32", "lo")
	addIp("10.0.10.20/24", "eth0")
	setLinkUp("lo")
	setLinkUp("eth0")

	createFile("/etc/passwd", 0644, []byte("root:x:0:0:root:/root:/bbin/elvish"))
	createFile("/etc/group", 0644, []byte("root:x:0:"))

	// TODO(bluecmd): Make conf persistent
	os.MkdirAll("/conf/", 0700)
	createFile("/conf/ssh_host_ecdsa_key", 0400, newSshKey())

	// The variable authorizedKeys is generated by Makefiles
	createFile("/conf/authorized_keys", 0600, []byte(strings.Join(authorizedKeys, "\n")))

	environ := append(os.Environ(), "USER=root")
	environ = append(environ, "HOME=/root")

	log.Printf("Starting gRPC interface\n")
	startGrpc()

	log.Printf("System startup\n")
	for _, line := range commands {
		log.Printf("Executing command: %v\n", line)
		cmdSplit := strings.Split(line, " ")
		if len(cmdSplit) == 0 {
			continue
		}

		go func() {
			cmd := exec.Command(cmdSplit[0], cmdSplit[1:]...)
			cmd.Env = environ
			cmd.Stdin = nil
			cmd.Stderr = os.Stderr
			cmd.Stdout = os.Stdout
			if err := cmd.Run(); err != nil {
				log.Print("Failed to execute: %v", err)
			}
		}()
	}

	log.Printf("Starting local shell\n")
	cmd := exec.Command("/bbin/elvish")
	cmd.Dir = "/root"
	cmd.Env = environ
	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	// Forward intr to the shell
	go intrHandler(cmd)
	if err := cmd.Run(); err != nil {
		log.Print("Failed to execute: %v", err)
	}

	log.Printf("Shell died, rebooting\n")
	cmd = exec.Command("/bbin/shutdown", "reboot")
	cmd.Env = environ
	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		log.Print("Failed to execute: %v", err)
	}

}
