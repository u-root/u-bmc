// Copyright 2018 the u-root Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bmc

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/x509"
	"encoding/pem"
	"io"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"strings"
	"syscall"

	"github.com/vishvananda/netlink"
	"golang.org/x/sys/unix"
)

type Platform interface {
	InitializeSystem() error
	HostUart() (string, int)
	GpioPlatform
	FanPlatform
}

func newSshKey() []byte {
	// No entropy, so use bad source for now
	f, err := os.Open("/dev/urandom")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	pk, err := ecdsa.GenerateKey(elliptic.P521(), f)
	if err != nil {
		panic(err)
	}

	asn1, err := x509.MarshalECPrivateKey(pk)
	if err != nil {
		panic(err)
	}
	return pem.EncodeToMemory(&pem.Block{Type: "EC PRIVATE KEY", Bytes: asn1})
}

func addIp(cidr string, iface string) {
	l, err := netlink.LinkByName(iface)
	if err != nil {
		log.Printf("Unable to get interface %s: %v", iface, err)
		return
	}

	addr, err := netlink.ParseAddr(cidr)
	if err != nil {
		log.Printf("netlink.ParseAddr %v: %v", cidr, err)
		return
	}

	h, err := netlink.NewHandle(unix.NETLINK_ROUTE)
	if err != nil {
		log.Printf("netlink.NewHandle: %v", err)
		return
	}
	defer h.Delete()
	if err := h.AddrReplace(l, addr); err != nil {
		log.Printf("AddrReplace(%v): %v", addr, err)
		return
	}
}

func setLinkUp(iface string) {
	l, err := netlink.LinkByName(iface)
	if err != nil {
		log.Printf("Unable to get interface %s: %v", iface, err)
		return
	}

	h, err := netlink.NewHandle(unix.NETLINK_ROUTE)
	if err != nil {
		log.Printf("netlink.NewHandle: %v", err)
		return
	}
	defer h.Delete()
	if err := h.LinkSetUp(l); err != nil {
		log.Printf("handle.LinkSetUp: %v", err)
		return
	}
}

func createFile(file string, mode os.FileMode, c []byte) {
	f, err := os.OpenFile(file, os.O_RDWR|os.O_CREATE, mode)
	if err != nil {
		log.Printf("Failed to write %v: %v", file, err)
		return
	}
	defer f.Close()
	f.Write(c)
}

func intrHandler(cmd *exec.Cmd) {
	for {
		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt)
		_ = <-c
		cmd.Process.Signal(os.Interrupt)
	}
}

func startSsh(environ []string) {
	cmd := exec.Command(
		"/bbin/sshd",
		"--ip", "[::0]",
		"--port", "22",
		"--privatekey", "/conf/ssh_host_ecdsa_key",
		"--keys", "/conf/authorized_keys")
	cmd.Env = environ
	cmd.Stdin = nil
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Start(); err != nil {
		log.Printf("Failed to execute: %v", err)
	}
}

func Startup(p Platform) {
	loggers := []io.Writer{os.Stdout}
	lf, err := os.OpenFile("/tmp/u-bmc.log", os.O_RDWR|os.O_CREATE, 0600)
	if err != nil {
		log.Printf("os.OpenFile u-bmc.log: %v", err)
	} else {
		loggers = append(loggers, lf)
		log.SetOutput(io.MultiWriter(loggers...))
	}

	log.Printf("Loading system configuration")
	syscall.Sethostname([]byte("ubmc"))

	// Fun story: if you don't have both IPv4 and IPv6 loopback configured
	// golang binaries will not bind to :: but to 0.0.0.0 instead.
	// Isn't that surprising?
	addIp("127.0.0.1/8", "lo")
	addIp("::1/32", "lo")
	addIp("10.0.10.20/24", "eth0")
	setLinkUp("lo")
	setLinkUp("eth0")

	createFile("/etc/passwd", 0644, []byte("root:x:0:0:root:/root:/bbin/elvish"))
	createFile("/etc/group", 0644, []byte("root:x:0:"))

	// TODO(bluecmd): Make conf persistent
	os.MkdirAll("/conf/", 0700)
	createFile("/conf/ssh_host_ecdsa_key", 0400, newSshKey())

	// The variable authorizedKeys is generated by Makefiles
	// TODO(bluecmd): The idea is to remove this for a StartSshServer RPC call.
	createFile("/conf/authorized_keys", 0600, []byte(strings.Join(authorizedKeys, "\n")))

	environ := append(os.Environ(), "USER=root")
	environ = append(environ, "HOME=/root")

	// The platform libraries need access to physical memory
	syscall.Mknod("/dev/mem", syscall.S_IFCHR|0600, 0x0101)

	log.Printf("Starting debug SSH server")
	// Make sure sshd starts up completely before we continue, to allow for debugging
	startSsh(environ)

	log.Printf("Initialize system hardware")
	p.InitializeSystem()
	if err != nil {
		log.Printf("platform.InitializeSystem: %v", err)
	}

	log.Printf("Starting GPIO drivers")
	gpio, err := startGpio(p)
	if err != nil {
		log.Printf("startGpio: %v", err)
	}

	log.Printf("Starting fan system")
	fan, err := startFan(p)
	if err != nil {
		log.Printf("startFan: %v", err)
	}

	tty, baud := p.HostUart()
	log.Printf("Configuring host UART console %s @ %d baud", tty, baud)
	uart, err := startUart(tty, baud)
	if err != nil {
		log.Printf("startUart: %v", err)
	}

	log.Printf("Starting gRPC interface")
	err = startGrpc(gpio, fan, uart)
	if err != nil {
		log.Printf("startGrpc: %v", err)
	}

	log.Printf("Starting local shell")
	cmd := exec.Command("/bbin/elvish")
	cmd.Dir = "/root"
	cmd.Env = environ
	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	// Forward intr to the shell
	go intrHandler(cmd)
	if err := cmd.Run(); err != nil {
		log.Printf("Failed to execute: %v", err)
	}

	log.Printf("Shell died, rebooting")
	cmd = exec.Command("/bbin/shutdown", "reboot")
	cmd.Env = environ
	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		log.Printf("Failed to execute: %v", err)
	}
}
